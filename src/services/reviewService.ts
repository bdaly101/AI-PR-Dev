import { GitHubClient } from '../github/client';
import { aiReviewer } from '../ai/reviewer';
import { fetchPRContext, isPRTooLarge, generateLargePRSummary } from '../github/prHelpers';
import { reviewRepo } from '../database/repositories/reviewRepo';
import { auditRepo } from '../database/repositories/auditRepo';
import { logger, logPRReview, logError } from '../utils/logging';
import { DEFAULT_IGNORE_PATTERNS } from '../config/constants';

class ReviewService {
  async reviewPullRequest(
    owner: string,
    repo: string,
    pullNumber: number,
    installationId: number
  ) {
    const prLogger = logPRReview(logger, owner, repo, pullNumber);
    const startTime = Date.now();
    
    try {
      const client = new GitHubClient(installationId);

      // Fetch complete PR context with caching and truncation
      prLogger.info('Fetching PR context');
      const context = await fetchPRContext(client, owner, repo, pullNumber, {
        useCache: true,
        ignorePatterns: DEFAULT_IGNORE_PATTERNS,
      });

      // Check if this commit has already been reviewed
      if (reviewRepo.hasBeenReviewed(owner, repo, context.commitSha)) {
        prLogger.info({ commitSha: context.commitSha }, 'Commit already reviewed, skipping');
        return;
      }

      // Handle PRs that are too large
      if (isPRTooLarge(context)) {
        prLogger.warn({ totalFiles: context.totalFiles }, 'PR too large for detailed review');
        
        const summary = generateLargePRSummary(context);
        await client.createIssueComment(owner, repo, pullNumber, summary);
        
        // Record that we handled this PR
        reviewRepo.recordReview({
          owner,
          repo,
          pull_number: pullNumber,
          commit_sha: context.commitSha,
          reviewed_at: new Date().toISOString(),
          model_used: 'skipped-too-large',
          review_summary: 'PR too large for detailed review',
        });
        
        return;
      }

      // Check if there's anything to review
      if (context.reviewedFiles === 0) {
        prLogger.info('No reviewable files in PR');
        await client.createIssueComment(
          owner,
          repo,
          pullNumber,
          '‚úÖ No reviewable code changes detected in this PR (files may be binary, ignored, or empty).'
        );
        return;
      }

      prLogger.info({
        reviewedFiles: context.reviewedFiles,
        fromCache: context.fromCache,
      }, 'Starting AI review');

      // Get AI review
      const review = await aiReviewer.reviewPullRequest(
        context.title,
        context.description,
        context.formattedDiff
      );

      // Format the review summary
      const riskEmoji = {
        low: 'üü¢',
        medium: 'üü°',
        high: 'üî¥',
      };

      let reviewBody = `## ü§ñ AI Code Review Summary\n\n`;
      reviewBody += `**Summary:** ${review.summary}\n\n`;
      reviewBody += `**Risk Level:** ${riskEmoji[review.riskLevel]} ${review.riskLevel.toUpperCase()}\n`;
      reviewBody += `**Risk Justification:** ${review.riskJustification}\n\n`;

      // Add context warnings if any
      if (context.warnings.length > 0) {
        reviewBody += `### ‚ö†Ô∏è Review Notes\n\n`;
        context.warnings.forEach((warning) => {
          reviewBody += `- ${warning}\n`;
        });
        reviewBody += `\n`;
      }

      if (review.generalComments.length > 0) {
        reviewBody += `### General Comments\n\n`;
        review.generalComments.forEach((comment) => {
          reviewBody += `- ${comment}\n`;
        });
        reviewBody += `\n`;
      }

      // Add review stats
      reviewBody += `### üìä Review Stats\n\n`;
      reviewBody += `- **Files Reviewed:** ${context.reviewedFiles}/${context.totalFiles}\n`;
      reviewBody += `- **Lines Changed:** +${context.totalAdditions}/-${context.totalDeletions}\n`;
      if (context.skippedFiles > 0) {
        reviewBody += `- **Files Skipped:** ${context.skippedFiles}\n`;
      }
      reviewBody += `\n`;

      reviewBody += `---\n`;
      reviewBody += `*This review was generated by AI. Please review the suggestions carefully.*\n`;
      reviewBody += `*Available commands: \`/ai-review\`, \`/ai-fix-lints\`*`;

      // Prepare inline comments - only for files that were actually reviewed
      const reviewedFilenames = new Set(
        context.files.filter(f => !f.skipped).map(f => f.filename)
      );
      
      const inlineComments = review.inlineComments
        .filter((comment) => reviewedFilenames.has(comment.file))
        .map((comment) => ({
          path: comment.file,
          line: comment.line,
          body: `üí° **AI Suggestion:**\n\n${comment.comment}`,
        }));

      // Post review with inline comments
      await client.createReview(
        owner,
        repo,
        pullNumber,
        reviewBody,
        'COMMENT',
        inlineComments
      );

      const duration = Date.now() - startTime;
      prLogger.info({ duration, inlineComments: inlineComments.length }, 'Review posted successfully');

      // Record the review
      reviewRepo.recordReview({
        owner,
        repo,
        pull_number: pullNumber,
        commit_sha: context.commitSha,
        reviewed_at: new Date().toISOString(),
        model_used: 'gpt-4',
        review_summary: review.summary,
      });

      // Audit log
      auditRepo.log({
        timestamp: new Date().toISOString(),
        action: 'pr_reviewed',
        owner,
        repo,
        pull_number: pullNumber,
        files_changed: context.files.map(f => f.filename).join(','),
        lines_added: context.totalAdditions,
        lines_deleted: context.totalDeletions,
        ai_model: 'gpt-4',
        success: 1,
      });

    } catch (error) {
      logError(prLogger, error, { action: 'review_pull_request' });
      
      // Audit log the failure
      auditRepo.log({
        timestamp: new Date().toISOString(),
        action: 'pr_review_failed',
        owner,
        repo,
        pull_number: pullNumber,
        ai_model: 'gpt-4',
        success: 0,
        error_message: error instanceof Error ? error.message : 'Unknown error',
      });
      
      // Try to post an error comment
      try {
        const client = new GitHubClient(installationId);
        await client.createIssueComment(
          owner,
          repo,
          pullNumber,
          '‚ùå Failed to generate AI review. Please check the logs for details.\n\n' +
          '*You can retry by commenting `/ai-review`*'
        );
      } catch (commentError) {
        logError(prLogger, commentError, { action: 'post_error_comment' });
      }
    }
  }
}

export const reviewService = new ReviewService();
